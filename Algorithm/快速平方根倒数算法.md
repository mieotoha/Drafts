(开场白：继承史诗，创造神话。大家好我是未絵音羽，当然也可以叫我洛诗旅)

今天我们来讲一下这段被载入史册的魔法(代码)——快速平方根倒数算法

> 事先说明：
> - 启发我写出这篇文章的是[这个视频](https://www.bilibili.com/video/BV1v64y1i7KH)
> - 这是32位时代的算法，请以32位为前提来读本篇所有的魔法(代码)
> - 要看懂这篇文章，你可能需要先具备高数的知识并且掌握二进制的知识

先让我们看看这段魔法(代码)

```c
float q_rsqrt(float number){
long i;
float x2, y;
const float threehalfs = 1.5F;

x2 = number * 0.5F;
y = number;
i = * (long * ) &y;                      // evil floating point bit level hacking
i = 0x5f3759df - (i >> 1);               // what the fuck?
y = * (float * ) &i;
y = y * (threehalfs - (x2 * y * y));     // 1st iteration
// y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed
}
```

看到这段魔法(代码)的大多数同学，估计最大的疑问应该是……
- 这个`0x5f3759df`是用来干嘛的？
- 算平方根的时候，这步有什么用途？
- <del>WTF？</del>

虽然这段代码已经过时了，但是同学们拿它来预习浮点数标准和牛顿迭代法也是很不错的

## 问题的来源

首先，为什么要求平方根倒数呢？

要在游戏引擎里实现物理效果，光影效果和反射效果的话，就需要把__向量单位化__，否则向量就会太长或者太短，这样得出的物理效果也会是错误的

![](/media/mieotoha/HotData/WorkSpace/Article/Notebook/assets/image/e7ed26163ac6540e/1.png)

向量单位化是为了得到一个长度等于`1`的向量，它有一个确定的方向

那么首先，求向量长度(模)的公式是

$$
\sqrt{x^2+y^2+z^2}
$$

(即x的平方加y的平方加z的平方的平方根)

此时如果要将向量单位化的话，我们需要将向量中的各个元素比上自己的模，以`x`为例，也就是将`x`轴的长度除以向量模长，它的公式是

$$
\frac{x}{\sqrt{x^2+y^2+z^2}}
$$

或者乘以向量模长的倒数，也就是

$$
x * \frac{1}{\sqrt{x^2+y^2+z^2}}
$$

__而求向量模长的倒数这一过程就是求平方根倒数__

在那个年代，平方根计算相当的慢，而一个3D模型往往有着上千个三角形平面，如果每个向量都要单位化，需要的时间太长了，所以

__如果求的是近似值，而算法很快，就能节省大量的时间__

而这个快速平方根倒数算法就是求近似值的算法，虽然有1%的误差，但是在那个时代速度远比`1/sqrt(x*x + y*y + z*z)`这段魔法(代码)快

## 分析代码

接下来我们回到魔法(代码)的第一行

```c
float q_rsqrt(float number){
    ......
}
```

第一行很简单，这个函数要求传入一个浮点数值`number`，而这个函数会计算这个`number`的平方根倒数

```c
long i;                           // 32位整形
float x2, y;                      // 32位单精度浮点数
const float threehalfs = 1.5F;    // 32位单精度浮点数常量
```

`threehalfs`的意思是`二分之三`

```c
x2 = number * 0.5F;
y = number;
```

接下来也只是很简单的将形参除以2后放入`x2`，完整的形参放入`y`

__现在，重点来了__

### IEEE 754 标准

首先，我们需要知道`IEEE 754`标准是什么，这是理解“evil floating point bit level hacking”这行魔法(代码)的重要知识

这是来自于科学计数法的灵感，在十进制中，我们通常这么表示


$$
0.00000000000000000016 = 1.6 \times 10^{-19}
$$

这个`10`便是`十进制`，它的指数决定了`1.6`的“位置”

那么在二进制我们也可以用类似的方法来表示

$$
0.01101 = 1.101 \times 2^{-2}
$$

而在二进制中表达小数的方式被规定成了`IEEE 754`，它的具体内容如下

首先我们有一个32位的空间，它的第一位表示正负，`0`表示正，`1`表示负

<center><font color="c97900">0</font> <font color="c979df">00000000</font> <font color="33bb33">00000000000000000000000</font></center><center><font color="c97900">+</font> x</center>

当然，在这个游戏引擎中它肯定是正数，因为如果如果去计算负数的平方根的话……

![](/media/mieotoha/HotData/WorkSpace/Article/Notebook/assets/image/e7ed26163ac6540e/危.png)

那肯定会有错误的

接下来的8位决定指数部分，也就是2的n次方

同样，它也用二进制来表示

虽然它的空间可以用来表示[0, 255]之间的数字，但是我们还需要表达负指数，于是区间就变成了[-127, 128]

因此这里表达的数字都会被减去127

例如`00000110`其实表达的是`6 - 127 = -121`

如果要表达`6`，正确的写法其实是`10000101`

结果就像下面这样

<center><font color="c97900">0</font> <font color="c979df">10000101</font> <font color="33bb33">00000000000000000000000</font></center><center><font color="c97900">+</font> x · 2⁶</center>

剩下的23位表示尾数，它能够表示[0, 2²³ - 1]之间的数字

接下来我们可以开始用它来表示小数了

你可能会想，在第一个零后面加上小数点就可以了

<center><font color="c97900">0</font> <font color="c979df">10000101</font> <font color="33bb33">0.0000000000000000000000</font></center><center><font color="c97900">+</font> 0.00 · 2⁶</center>

但事实上这是对位空间的一种浪费，让我们回到科学计数法

根据科学计数法的定义，第一位肯定不是零，也就是不存在

$$
0.1 \times 10^6
$$

这样的数

而二进制中只有一个数字表示非零，那就是`1`

__那么我们就可以确定在二进制的科学计数法中，无论在什么情况下，第一个数字肯定是`1`__

__如果第一位数字永远是`1`的话，我们也就没有必要去存储它了__

也就是说，把小数点移到左边

<center><font color="c97900">0</font> <font color="c979df">10000101</font> <font color="33bb33">.00000000000000000000000</font></center><center><font color="c97900">+</font> 1.00 · 2⁶</center>

__这便是`IEEE 754`标准中的规格化数__

虽然`IEEE 754`中还有非规格化数、非数、无穷和+0与-0，但是这个算法恰好不会涉及到这些内容

根本没必要让一个游戏引擎去单位化一个无限长的向量，对吧

### 二进制与掉头发的高数
